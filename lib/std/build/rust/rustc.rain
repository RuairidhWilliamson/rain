let std = import("std.rain")

let get_file = std.utils.get_file
let get_dir = std.utils.get_dir
let escape_bin = std.utils.escape_bin
let run = std.utils.run
let unit = std.utils.unit
let _throw = std.utils._throw

let zig = std.build.zig.dist.download("0.14.1", "x86_64", "linux")

let zig_linker = fn() {
	linker_script = std.utils.create_file("#!/bin/sh\n" + std.utils.stringify(zig) + " cc \"$@\"", "zig_linker.sh")
	std.utils.run_check(unit, std.escape.bin("chmod"), ["a+x", linker_script], {})
	linker_script
}

let compile = fn(channel, src, outname, target, edition, extra_args) {
	// Implicitly requires cc for linking
	// cc = escape_bin("cc")

	// Download components
	rustc = std.build.rust.dist.get_rustc(channel, std.utils.host_info().triple)
	rust_std = std.build.rust.dist.get_rust_std(channel, target)

	merged = std.utils.create_area([rustc, rust_std])
	env = {
		LD_LIBRARY_PATH = get_dir(merged, "/lib"),
		ZIG_GLOBAL_CACHE_DIR = ".",
	}
	rustc_bin = get_file(merged, "/bin/rustc")
	args = [
		src,
		"-o", outname,
		"--color", "always",
		"--target", target,
		"--edition", edition,
		"--emit", "dep-info,link",
		"-C", "linker=" + std.utils.stringify(zig_linker()),
	] + extra_args
	run_result = run(unit, rustc_bin, args, env)
	if !run_result.success {
		std.utils.print(run_result.stderr)
		_throw("rustc compilation failed")
	}
	get_file(run_result.area, outname + std.utils.exe_suffix(target))
}
