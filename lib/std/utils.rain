// utils.rain is designed to be removed in the future but provides useful APIs
let types = import("types.rain")

let print = internal._print
let debug = internal._debug
let get_file = internal._get_file
let module_file = internal._module_file
let extract_zip = internal._extract_zip
let extract_tar_gz = internal._extract_tar_gz
let extract_tar_xz = internal._extract_tar_xz
let run = internal._run
let escape_bin = internal._escape_bin
let unit = internal._unit()
let get_area = internal._get_area
let sha256 = internal._sha256
let sha512 = internal._sha512
let bytes_to_string = internal._bytes_to_string
let parse_toml = internal._parse_toml
let create_area = internal._create_area
let read_file = internal._read_file
let create_file = internal._create_file
let get_dir = internal._get_dir
let local_area = internal._local_area
let split_string = internal._split_string
let index = internal._index
let host_info = internal._host_info
let string_contains = internal._string_contains
let export_to_local = internal._export_to_local
let check_export_to_local = internal._check_export_to_local
let file_metadata = internal._file_metadata
let glob = internal._glob
let foreach = internal._foreach
let stringify = internal._stringify
let escape_run = internal._escape_run
let create_tar = internal._create_tar

let String = types.String
let List = types.List
let File = types.File
let Bool = types.Bool

// Reserved keywords are prefixed with _
let _import = internal._import
let _throw = internal._throw

let download = fn(url) {
	internal._download(url)
}

let download_with_sha256 = fn(url: String, sha256: String) -> File {
	download_result = internal._download(url)
	actual_sha256 = internal._sha256(download_result.file)
	if actual_sha256 != sha256 {
		internal._throw("bad sha256 " + actual_sha256)
	}
	download_result.file
}

let run_check = fn(area, bin, args: List, env) {
	run_result = run(area, bin, args, env)
	if !run_result.success {
		print("Stdout:", run_result.stdout)
		print("Stderr:", run_result.stderr)
		_throw("run failed")
	}
	run_result
}

let newline = "\n"

let exe_suffix = fn(target_triple: String) -> String {
	if is_windows(target_triple) {
		".exe"
	} else {
		""
	}
}

let shared_library_prefix = fn(target_triple: String) -> String {
	if is_windows(target_triple) {
		""
	} else if is_linux(target_triple) {
		"lib"
	} else {
		_throw("unknown target: " + target_triple)
	}
}

let shared_library_suffix = fn(target_triple: String) -> String {
	if is_windows(target_triple) {
		".dll"
	} else if is_linux(target_triple) {
		".so"
	} else {
		_throw("unknown target: " + target_triple)
	}
}

let is_linux = fn(target_triple: String) -> Bool {
	string_contains(target_triple, "-linux-")
}

let is_windows = fn(target_triple: String) -> Bool {
	string_contains(target_triple, "-windows-")
}

let is_amd64 = fn(target_triple: String) -> Bool {
	string_contains(target_triple, "x86_64")
}

let rename_file = fn(file: File, new_name: String) -> File {
	internal._copy_file(file, new_name)
}

let path_var_separator = fn(target_triple) {
	if is_windows(target_triple) {
		";"
	} else {
		":"
	}
}
