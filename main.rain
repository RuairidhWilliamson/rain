let area = internal._get_area(this_file)
pub let std = load_stdlib()
let publish_module = import("publish.rain")
let test_mod = import("test.rain")
let examples = import("examples/_.rain")
let hermetic = import("hermetic.rain")

let load_stdlib = fn() {
	stdlib_area = internal._create_area([internal._get_dir(area, "lib/std")])
	internal._embed().load_stdlib(stdlib_area)
}

let {print} = std
let {String, File} = std.types

let cargo = std.escape.bin("cargo")

let cargo_env =  {
	CARGO_TERM_COLOR = "always",
	CARGO_TERM_QUIET = "true",
}

pub let lint = fn() {
	check_empty_files()
}

let ci = fn() {
	check()
}

pub let check = fn() {
	lint()
	clippy()
	test()
}

let build = fn() {
	std.build.rust.cargo.build(std.build.rust.stable, area, "rain", true, "", "dev", std.utils.host_info().triple, [], {})
}

pub let build_release = fn(target_triple: String) -> File {
	args = [
		"build",
		"--package", "rain",
		"--target", target_triple,
		"--release",
		"--no-default-features",
	]
	std.escape.run(area, cargo, args, cargo_env)
	std.fs.file(area, "target/" + target_triple + "/release/rain" + std.utils.exe_suffix(target_triple))
}

let build_c = fn() {
	std.build.cc.gcc.compile(std.fs.file(area, "core/examples/run/foo.c"), "foo")
}

let run = fn() {
	binary = build_c()
	std.utils.run(std.utils.unit, binary, [], {})
}

let helloworld = fn() {
	src = std.utils.create_file("fn main() {\n\tprintln!(\"Hello world!\")\n}", "helloworld.rs")
	bin = std.build.rust.rustc.compile("stable", src, "helloworld", std.utils.host_info().triple, "2024")
	print(std.utils.run(std.utils.unit, bin, [], {}).stdout)
}

let check_empty_files = fn() {
	std.list.map(std.utils.glob(area), std.build.lints.no_emptish)
}

let everything = fn() {
	check()
	build()
	run()
	download_test()
	print_some_stuff()
}

let test_zig = fn() {
	src = std.utils.create_file("const std = @import(\"std\"); pub fn main() !void {std.debug.print(\"hello world\", .{});}", "helloworld.zig")
	zig_bin = std.build.zig.dist.download("0.15.1", "x86_64", "linux")
	run_result = std.utils.run(std.utils.unit, zig_bin, ["build-exe", src], {ZIG_GLOBAL_CACHE_DIR = "."})
	if !run_result.success {
		print("Stdout:", run_result.stdout)
		print("Stderr:", run_result.stderr)
		std.utils._throw("build zig")
	}
	bin = std.fs.file(run_result.area, "helloworld")
	run_result = std.utils.run(std.utils.unit, bin, [], {})
	if !run_result.success {
		std.utils._throw("zig helloworld")
	}
	print(run_result.stderr)
}

pub let publish = fn(version: String) {
	publish_module.publish(version)
}

pub let install_cli = fn() {
	std.escape.run(area, cargo, ["install", "--path", "cli", "--locked"], cargo_env)
	std.utils.unit
}

pub let test = fn() {
	test_mod.test_caching()
	regular_test()
}

let clippy = fn() {
	std.escape.run(area, cargo, ["clippy"], cargo_env)
	std.utils.unit
}

let regular_test = fn() {
	std.escape.run(area, cargo, ["test", "-q"], cargo_env)
	std.utils.unit
}

let nextest = fn() {
	std.escape.run(area, cargo, ["nextest", "run"], cargo_env)
	std.utils.unit
}

let coverage = fn() -> File {
	std.escape.run(area, cargo, ["llvm-cov", "nextest", "-p", "rain-lang", "-p", "rain-core", "--html"], cargo_env)
	std.fs.file(area, "target/llvm-cov/html/index.html")
}

let cleanup_snapshots = fn() {
	std.escape.run(area, cargo, ["insta", "test", "--unreferenced", "delete"], cargo_env)
	std.utils.unit
}
